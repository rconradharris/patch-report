#!/usr/bin/env python
"""
Send notification emails

usage: send-notification-emails [--dry-run] [--verbose] <since>

--dry-run       Don't actually send the email
--verbose       Output logging information to stderr
since           String representing how long ago to pull activities from (e.g.
                '5 minutes ago')

Intended to be run from a cron-job.

NB: A good rule of thumb is to make `since` twice what your cronjob interval
is.  So, if you're running this script every 10 minutes, set `since` to `20
minutes ago`.

This script uses a `sent-emails` file to keep track of which emails it has
already sent. This is used for two purposes:

    1) Prevent duplicate emails from being sent to a user

    2) Avoid a race where an email might not be sent if it occurs right on the
       edge of a send-email interval. For example, if our send-email interval
       is 10 minutes, and we're pulling activities from 10 minutes ago, if it
       takes a second or two to start the cronjob, then those 1 or 2 seconds
       of activities will be lost.

       The `sent-emails` file fixes this by allowing us to pull activities
       from a much larger, overlapping window, and then filtering out any
       already sent emails.
"""
import calendar
import datetime
import email.utils
from email.mime.text import MIMEText
import hashlib
import smtplib
import sys

import requests

from patch_report import cache
from patch_report import config
from patch_report import simplelog
from patch_report import utils
from patch_report.models.patch_report import get_from_cache

PIDFILE = '/tmp/send-notification-emails.pid'
RESET_CACHE_PIDFILE = '/tmp/reset-cache.pid'
SENT_EMAILS_FILENAME = 'sent-emails'
MAX_AGE = 86400


class Message(object):
    def __init__(self, sender, recipient, subject, body, date=None):
        self.sender = sender
        self.recipient = recipient
        self.subject = subject
        self.body = body
        self.date = date
        self.message_id = email.utils.make_msgid()
        self.hash = self._compute_hash()

    def as_mime(self):
        msg = MIMEText(self.body)
        msg['To'] = self.recipient
        msg['From'] = self.sender
        msg['Subject'] = self.subject
        msg['Date'] = email.utils.formatdate(self.date, localtime=True)
        # see RFC 5322 section 3.6.4.
        msg['Message-ID'] = self.message_id
        return msg

    def as_string(self):
        return self.as_mime().as_string()

    def __repr__(self):
        return "<Message to='%s' subject='%s'>" % (self.recipient, self.subject)

    def _compute_hash(self):
        parts = [self.body, self.subject, self.sender, self.recipient]
        return hashlib.sha1('+'.join(parts)).hexdigest()


def _get_messages(email_config, patch_report, since):
    sender = email_config['sender']
    recipients = email_config['recipients'].split(',')

    messages = []
    for repo in patch_report.repos:
        for activity in repo.get_patch_activities(since):
            patch = activity.patch
            if activity.what == 'create':
                for recipient in recipients:
                    subject = "[NEW PATCH] [%s]: %s" % (activity.repo.name,
                                                        patch.filename)
                    message = Message(
                            sender, recipient, subject, patch.contents)
                    messages.append(message)

    return messages

def _send_smtp(messages, email_config, verbose):
    server = smtplib.SMTP_SSL(email_config['hostname'], email_config['port'])
    try:
        server.set_debuglevel(verbose)

        # identify ourselves, prompting server for supported features
        server.ehlo()

        # If we can encrypt this session, do it
        if server.has_extn('STARTTLS'):
            server.starttls()
            server.ehlo() # re-identify ourselves over TLS connection

        server.login(email_config['username'], email_config['password'])
        for message in messages:
            server.sendmail(message.sender, [message.recipient], message.as_string())
            simplelog.log("Successfully sent {0}".format(message))
    finally:
        server.quit()


def _send_mailgun(messages, email_config, verbose):
    if not email_config.get('url'):
        raise Exception('Must set URL to send email via mailgun')

    for message in messages:
        data = {'from': message.sender,
                'to': message.recipient,
                'subject': message.subject,
                'text': message.body}
        r = requests.post(email_config['url'],
                          data=data,
                          auth=(email_config['username'],
                                email_config['password']))
        if r.status_code == 200:
            simplelog.log("Successfully sent {0}".format(message))
        else:
            simplelog.log("error: Received HTTP status {0} trying"
                          " to send {1}".format(r.status_code, message))


def _send_dry_run(messages, email_config, verbose):
    for message in messages:
        simplelog.log(message)


def _send_emails(messages, email_config, verbose, dry_run):
    if dry_run:
        transport = 'dry_run'
    else:
        transport = email_config['transport']

    simplelog.log("Using transport '{0}' to send email".format(transport))
    if transport == 'dry_run':
        _send_dry_run(messages, email_config, verbose)
    elif transport == 'smtp':
        _send_smtp(messages, email_config, verbose)
    elif transport == 'mailgun':
        _send_mailgun(messages, email_config, verbose)
    else:
        raise Exception('Unknown transport method for email: {0}'.format(
                        transport))


def _filter_already_sent_messages(messages, sent_emails):
    remove = []
    for message in messages:
        if message.hash in sent_emails:
            remove.append(message)

    for message in remove:
        simplelog.log("Message {0} was already sent, skipping...".format(
                      message))
        messages.remove(message)


def _prune_and_write_sent_emails(messages, sent_emails):
    utcnow = calendar.timegm(datetime.datetime.utcnow().utctimetuple())

    # Add successfully sent messages to sent_emails dict
    for message in messages:
        sent_emails[message.hash] = utcnow

    # Prune out old entries to keep file from growing too large
    remove = []
    for message_hash, sent in sent_emails.iteritems():
        age = utcnow - sent
        if age > MAX_AGE:
            remove.append(message_hash)

    for message_hash in remove:
        simplelog.log("Pruning old sent_email key '{0}'".format(message_hash))
        del sent_emails[message_hash]

    # Write to disk
    simplelog.log("Writing sent_emails cache")
    cache.write_file(SENT_EMAILS_FILENAME, sent_emails)


def main(dry_run, verbose, since):
    email_config = config.get_section('email')
    if not email_config:
        simplelog.log("error: Email is not configured")
        sys.exit(1)

    if since.startswith('--'):
        print >> sys.stderr, "usage: send-notification-emails"\
                             " [--dry-run] [--verbose] <since>"
        sys.exit(1)

    test_recipient = email_config['test_recipient']
    if test_recipient:
        simplelog.log('Sending test email to test recipient: {0}'.format(
                      test_recipient))
        messages = [Message(email_config['sender'],
                            test_recipient,
                            'PatchReport Test Email',
                            'This is a test email')]
    else:
        patch_report = get_from_cache()
        messages = _get_messages(email_config, patch_report, since)

    try:
        sent_emails = cache.read_file(SENT_EMAILS_FILENAME)
    except cache.CacheFileNotFound:
        sent_emails = {}

    _filter_already_sent_messages(messages, sent_emails)
    _send_emails(messages, email_config, verbose, dry_run)
    _prune_and_write_sent_emails(messages, sent_emails)


if __name__ == '__main__':
    args = sys.argv[1:]
    dry_run = '--dry-run' in args
    verbose = '--verbose' in args
    since = args[-1]

    simplelog.set_verbose(verbose)

    utils.pidfile_guard(RESET_CACHE_PIDFILE)
    utils.pidfile_guard(PIDFILE)

    with utils.pidfile_context(PIDFILE):
        main(dry_run, verbose, since)
