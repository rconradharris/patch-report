#!/usr/bin/env python
"""
Send notification emails

usage: send-notification-emails [--dry-run] [--verbose] <since>

--dry-run       Don't actually send the email
--verbose       Output logging information to stderr
since           String representing how long ago to pull activities from (e.g.
                '5 minutes ago')

Intended to be run from a cron-job.
"""
import email.utils
from email.mime.text import MIMEText
import smtplib
import sys

import requests

from patch_report import config
from patch_report import simplelog
from patch_report import utils
from patch_report.models.patch_report import get_from_cache

PIDFILE = '/tmp/send-notification-emails.pid'
RESET_CACHE_PIDFILE = '/tmp/reset-cache.pid'


class Message(object):
    def __init__(self, sender, recipient, subject, body, date=None):
        self.sender = sender
        self.recipient = recipient
        self.subject = subject
        self.body = body
        self.date = date
        self.message_id = email.utils.make_msgid()

    def as_mime(self):
        msg = MIMEText(self.body)
        msg['To'] = self.recipient
        msg['From'] = self.sender
        msg['Subject'] = self.subject
        msg['Date'] = email.utils.formatdate(self.date, localtime=True)
        # see RFC 5322 section 3.6.4.
        msg['Message-ID'] = self.message_id
        return msg

    def as_string(self):
        return self.as_mime().as_string()

    def __repr__(self):
        return "<Message to='%s' subject='%s'>" % (self.recipient, self.subject)


def _get_messages(email_config, patch_report, since):
    sender = email_config['sender']
    recipients = email_config['recipients'].split(',')

    messages = []
    for repo in patch_report.repos:
        for activity in repo.get_patch_activities(since):
            patch = activity.patch
            if activity.what == 'create':
                for recipient in recipients:
                    subject = "[NEW PATCH] [%s]: %s" % (activity.repo.name,
                                                        patch.filename)
                    message = Message(
                            sender, recipient, subject, patch.contents)
                    messages.append(message)

    return messages

def _send_smtp(messages, email_config, verbose):
    server = smtplib.SMTP_SSL(email_config['hostname'], email_config['port'])
    try:
        server.set_debuglevel(verbose)

        # identify ourselves, prompting server for supported features
        server.ehlo()

        # If we can encrypt this session, do it
        if server.has_extn('STARTTLS'):
            server.starttls()
            server.ehlo() # re-identify ourselves over TLS connection

        server.login(email_config['username'], email_config['password'])
        for message in messages:
            server.sendmail(message.sender, [message.recipient], message.as_string())
            simplelog.log("Successfully sent {0}".format(message))
    finally:
        server.quit()


def _send_mailgun(messages, email_config, verbose):
    if not email_config.get('url'):
        raise Exception('Must set URL to send email via mailgun')

    for message in messages:
        data = {'from': message.sender,
                'to': message.recipient,
                'subject': message.subject,
                'text': message.body}
        r = requests.post(email_config['url'],
                          data=data,
                          auth=(email_config['username'],
                                email_config['password']))
        if r.status_code == 200:
            simplelog.log("Successfully sent {0}".format(message))
        else:
            simplelog.log("error: Received HTTP status {0} trying"
                          " to send {1}".format(r.status_code, message))


def _send_dry_run(messages, email_config, verbose):
    for message in messages:
        simplelog.log(message)


def _send_emails(messages, email_config, verbose, dry_run):
    if dry_run:
        transport = 'dry_run'
    else:
        transport = email_config['transport']

    simplelog.log("Using transport '{0}' to send email".format(transport))
    if transport == 'dry_run':
        _send_dry_run(messages, email_config, verbose)
    elif transport == 'smtp':
        _send_smtp(messages, email_config, verbose)
    elif transport == 'mailgun':
        _send_mailgun(messages, email_config, verbose)
    else:
        raise Exception('Unknown transport method for email: {0}'.format(
                        transport))

def main(dry_run, verbose, since):
    email_config = config.get_section('email')
    if not email_config:
        simplelog.log("error: Email is not configured")
        sys.exit(1)

    if since.startswith('--'):
        print >> sys.stderr, "usage: send-notification-emails"\
                             " [--dry-run] [--verbose] <since>"
        sys.exit(1)

    test_recipient = email_config['test_recipient']
    if test_recipient:
        simplelog.log('Sending test email to test recipient: {0}'.format(
                      test_recipient))
        messages = [Message(email_config['sender'],
                            test_recipient,
                            'PatchReport Test Email',
                            'This is a test email')]
    else:
        patch_report = get_from_cache()
        messages = _get_messages(email_config, patch_report, since)

    _send_emails(messages, email_config, verbose, dry_run)


if __name__ == '__main__':
    args = sys.argv[1:]
    dry_run = '--dry-run' in args
    verbose = '--verbose' in args
    since = args[-1]

    simplelog.set_verbose(verbose)

    utils.pidfile_guard(RESET_CACHE_PIDFILE)
    utils.pidfile_guard(PIDFILE)

    with utils.pidfile_context(PIDFILE):
        main(dry_run, verbose, since)
