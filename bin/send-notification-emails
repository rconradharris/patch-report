#!/usr/bin/env python
"""
Send notification emails

usage: send-notification-emails [--dry-run] [--reset] [--verbose] <since>

--dry-run       Don't actually send the email
--reset         Allow refresh during a cache reset
--verbose       Output logging information to stderr
since           String representing how long ago to pull activities from (e.g.
                '5 minutes ago')

Intended to be run from a cron-job.
"""
import email.utils
from email.mime.text import MIMEText
import os
import smtplib
import sys


from patch_report import config
from patch_report import simplelog
from patch_report import utils
from patch_report.models.patch_report import get_from_cache

PIDFILE = '/tmp/send-notification-emails.pid'
RESET_CACHE_PIDFILE= '/tmp/reset-cache.pid'


class Message(object):
    def __init__(self, sender, recipient, subject, body, date=None):
        self.sender = sender
        self.recipient = recipient
        self.subject = subject
        self.body = body
        self.date = date
        self.message_id = email.utils.make_msgid()

    def as_mime(self):
        msg = MIMEText(self.body)
        msg['To'] = self.recipient
        msg['From'] = self.sender
        msg['Subject'] = self.subject
        msg['Date'] = email.utils.formatdate(self.date, localtime=True)
        # see RFC 5322 section 3.6.4.
        msg['Message-ID'] = self.message_id
        return msg

    def as_string(self):
        return self.as_mime().as_string()

    def __repr__(self):
        return "<Message to='%s' subject='%s'>" % (self.recipient, self.subject)


def _get_messages(email_config, patch_report, since):
    sender = email_config['sender']
    recipients = email_config['recipients'].split(',')

    for repo in patch_report.repos:
        for activity in repo.get_patch_activities(since):
            patch = activity.patch
            if activity.what == 'create':
                for recipient in recipients:
                    subject = "[NEW PATCH] [%s]: %s" % (activity.repo.name,
                                                        patch.filename)
                    yield Message(sender, recipient, subject, patch.contents)


def _send_emails(email_config, messages, verbose):
    server = smtplib.SMTP_SSL(email_config['hostname'], email_config['port'])
    try:
        server.set_debuglevel(verbose)

        # identify ourselves, prompting server for supported features
        server.ehlo()

        # If we can encrypt this session, do it
        if server.has_extn('STARTTLS'):
            server.starttls()
            server.ehlo() # re-identify ourselves over TLS connection

        server.login(email_config['username'], email_config['password'])
        for message in messages:
            server.sendmail(message.sender, [message.recipient], message.as_string())
    finally:
        server.quit()


def main(since, dry_run, verbose):
    simplelog.set_verbose(verbose)

    email_config = config.get_section('email')
    if not email_config:
        sys.exit(1)

    if since.startswith('--'):
        print >> sys.stderr, "usage: send-notification-emails"\
                             " [--dry-run] [--reset] [--verbose] <since>"
        sys.exit(1)


    patch_report = get_from_cache()

    messages = _get_messages(email_config, patch_report, since)
    if dry_run:
        for message in messages:
            print message
    else:
        _send_emails(email_config, messages, verbose)


if __name__ == '__main__':
    args = sys.argv[1:]
    dry_run = '--dry-run' in args
    reset = '--reset' in args
    verbose = '--verbose' in args

    since = args[-1]

    if os.path.exists(RESET_CACHE_PIDFILE) and not reset:
        sys.exit(0)

    with utils.pidfile_guard(PIDFILE):
        main(since, dry_run, verbose)
